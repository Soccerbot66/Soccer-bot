CCS PCM C Compiler, Version 4.104, 5967               15-may-18 15:01

               Filename: C:\Users\Fernando\Documents\ELECTRONICA DIGITAL2\LENGUAJEC\ROBOT\robot.lst

               ROM used: 2781 words (34%)
                         Largest free fragment is 2048
               RAM used: 47 (13%) at main() level
                         72 (20%) worst case
               Stack:    6 locations

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   26A
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................  
.................... #device adc=10                         // Usa resolución de 10 bits 
.................... #fuses XT,NOWDT,NOPROTECT,NOLVP,NOPUT,NODEBUG,NOCPD,NOBROWNOUT  
.................... #use delay(clock=4000000) 
*
0124:  MOVLW  57
0125:  MOVWF  04
0126:  BCF    03.7
0127:  MOVF   00,W
0128:  BTFSC  03.2
0129:  GOTO   138
012A:  MOVLW  01
012B:  MOVWF  78
012C:  CLRF   77
012D:  DECFSZ 77,F
012E:  GOTO   12D
012F:  DECFSZ 78,F
0130:  GOTO   12C
0131:  MOVLW  4A
0132:  MOVWF  77
0133:  DECFSZ 77,F
0134:  GOTO   133
0135:  GOTO   136
0136:  DECFSZ 00,F
0137:  GOTO   12A
0138:  RETURN
.................... #define lcd_rs_pin pin_d3 
.................... #define lcd_rw_pin pin_A4  
.................... #define lcd_enable_pin pin_d2 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00D1:  MOVLW  0F
00D2:  ANDWF  08,W
00D3:  IORLW  F0
00D4:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D5:  BCF    03.5
00D6:  BSF    05.4
00D7:  BSF    03.5
00D8:  BCF    05.4
....................    delay_cycles(1); 
00D9:  NOP
....................    lcd_output_enable(1); 
00DA:  BCF    03.5
00DB:  BSF    08.2
00DC:  BSF    03.5
00DD:  BCF    08.2
....................    delay_cycles(1); 
00DE:  NOP
....................    high = lcd_read_nibble(); 
00DF:  BCF    03.5
00E0:  CALL   0B6
00E1:  MOVF   78,W
00E2:  MOVWF  5E
....................        
....................    lcd_output_enable(0); 
00E3:  BCF    08.2
00E4:  BSF    03.5
00E5:  BCF    08.2
....................    delay_cycles(1); 
00E6:  NOP
....................    lcd_output_enable(1); 
00E7:  BCF    03.5
00E8:  BSF    08.2
00E9:  BSF    03.5
00EA:  BCF    08.2
....................    delay_us(1); 
00EB:  NOP
....................    low = lcd_read_nibble(); 
00EC:  BCF    03.5
00ED:  CALL   0B6
00EE:  MOVF   78,W
00EF:  MOVWF  5D
....................        
....................    lcd_output_enable(0); 
00F0:  BCF    08.2
00F1:  BSF    03.5
00F2:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00F3:  MOVLW  0F
00F4:  ANDWF  08,W
00F5:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00F6:  BCF    03.5
00F7:  SWAPF  5E,W
00F8:  MOVWF  77
00F9:  MOVLW  F0
00FA:  ANDWF  77,F
00FB:  MOVF   77,W
00FC:  IORWF  5D,W
00FD:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00B6:  MOVF   08,W
00B7:  MOVWF  77
00B8:  SWAPF  08,W
00B9:  ANDLW  0F
00BA:  MOVWF  78
....................   #endif 
.................... } 
00BB:  RETURN
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
00BC:  SWAPF  5E,W
00BD:  ANDLW  F0
00BE:  MOVWF  77
00BF:  MOVLW  0F
00C0:  ANDWF  08,W
00C1:  IORWF  77,W
00C2:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
00C3:  NOP
....................    lcd_output_enable(1); 
00C4:  BSF    08.2
00C5:  BSF    03.5
00C6:  BCF    08.2
....................    delay_us(2); 
00C7:  GOTO   0C8
....................    lcd_output_enable(0); 
00C8:  BCF    03.5
00C9:  BCF    08.2
00CA:  BSF    03.5
00CB:  BCF    08.2
.................... } 
00CC:  BCF    03.5
00CD:  RETURN
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
00CE:  BCF    08.3
00CF:  BSF    03.5
00D0:  BCF    08.3
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
00FE:  MOVF   78,W
00FF:  MOVWF  5D
0100:  BTFSS  5D.7
0101:  GOTO   104
0102:  BSF    03.5
0103:  GOTO   0D1
....................    lcd_output_rs(address); 
0104:  MOVF   5B,F
0105:  BTFSS  03.2
0106:  GOTO   109
0107:  BCF    08.3
0108:  GOTO   10A
0109:  BSF    08.3
010A:  BSF    03.5
010B:  BCF    08.3
....................    delay_cycles(1); 
010C:  NOP
....................    lcd_output_rw(0); 
010D:  BCF    03.5
010E:  BCF    05.4
010F:  BSF    03.5
0110:  BCF    05.4
....................    delay_cycles(1); 
0111:  NOP
....................    lcd_output_enable(0); 
0112:  BCF    03.5
0113:  BCF    08.2
0114:  BSF    03.5
0115:  BCF    08.2
....................    lcd_send_nibble(n >> 4); 
0116:  BCF    03.5
0117:  SWAPF  5C,W
0118:  MOVWF  5D
0119:  MOVLW  0F
011A:  ANDWF  5D,F
011B:  MOVF   5D,W
011C:  MOVWF  5E
011D:  CALL   0BC
....................    lcd_send_nibble(n & 0xf); 
011E:  MOVF   5C,W
011F:  ANDLW  0F
0120:  MOVWF  5D
0121:  MOVWF  5E
0122:  CALL   0BC
.................... } 
0123:  RETURN
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
*
01B6:  MOVLW  0F
01B7:  BSF    03.5
01B8:  ANDWF  08,W
01B9:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
01BA:  BCF    08.2
....................    lcd_rs_tris(); 
01BB:  BCF    08.3
....................    lcd_rw_tris(); 
01BC:  BCF    05.4
....................  #endif 
....................  
....................    lcd_output_rs(0); 
01BD:  BCF    03.5
01BE:  BCF    08.3
01BF:  BSF    03.5
01C0:  BCF    08.3
....................    lcd_output_rw(0); 
01C1:  BCF    03.5
01C2:  BCF    05.4
01C3:  BSF    03.5
01C4:  BCF    05.4
....................    lcd_output_enable(0); 
01C5:  BCF    03.5
01C6:  BCF    08.2
01C7:  BSF    03.5
01C8:  BCF    08.2
....................      
....................    delay_ms(15); 
01C9:  MOVLW  0F
01CA:  BCF    03.5
01CB:  MOVWF  57
01CC:  CALL   124
....................    for(i=1;i<=3;++i) 
01CD:  MOVLW  01
01CE:  MOVWF  49
01CF:  MOVF   49,W
01D0:  SUBLW  03
01D1:  BTFSS  03.0
01D2:  GOTO   1DB
....................    { 
....................        lcd_send_nibble(3); 
01D3:  MOVLW  03
01D4:  MOVWF  5E
01D5:  CALL   0BC
....................        delay_ms(5); 
01D6:  MOVLW  05
01D7:  MOVWF  57
01D8:  CALL   124
....................    } 
01D9:  INCF   49,F
01DA:  GOTO   1CF
....................      
....................    lcd_send_nibble(2); 
01DB:  MOVLW  02
01DC:  MOVWF  5E
01DD:  CALL   0BC
....................    for(i=0;i<=3;++i) 
01DE:  CLRF   49
01DF:  MOVF   49,W
01E0:  SUBLW  03
01E1:  BTFSS  03.0
01E2:  GOTO   1EC
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01E3:  MOVF   49,W
01E4:  CALL   004
01E5:  MOVWF  4A
01E6:  CLRF   5B
01E7:  MOVF   4A,W
01E8:  MOVWF  5C
01E9:  CALL   0CE
01EA:  INCF   49,F
01EB:  GOTO   1DF
.................... } 
01EC:  RETURN
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0139:  DECFSZ 58,W
013A:  GOTO   13C
013B:  GOTO   13F
....................       address=LCD_LINE_TWO; 
013C:  MOVLW  40
013D:  MOVWF  59
....................    else 
013E:  GOTO   140
....................       address=0; 
013F:  CLRF   59
....................       
....................    address+=x-1; 
0140:  MOVLW  01
0141:  SUBWF  57,W
0142:  ADDWF  59,F
....................    lcd_send_byte(0,0x80|address); 
0143:  MOVF   59,W
0144:  IORLW  80
0145:  MOVWF  5A
0146:  CLRF   5B
0147:  MOVF   5A,W
0148:  MOVWF  5C
0149:  CALL   0CE
.................... } 
014A:  RETURN
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
014B:  MOVF   56,W
014C:  XORLW  0C
014D:  BTFSC  03.2
014E:  GOTO   156
014F:  XORLW  06
0150:  BTFSC  03.2
0151:  GOTO   15E
0152:  XORLW  02
0153:  BTFSC  03.2
0154:  GOTO   164
0155:  GOTO   169
....................       case '\f'   :  lcd_send_byte(0,1); 
0156:  CLRF   5B
0157:  MOVLW  01
0158:  MOVWF  5C
0159:  CALL   0CE
....................                      delay_ms(2); 
015A:  MOVLW  02
015B:  MOVWF  57
015C:  CALL   124
....................                      break; 
015D:  GOTO   16F
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
015E:  MOVLW  01
015F:  MOVWF  57
0160:  MOVLW  02
0161:  MOVWF  58
0162:  CALL   139
0163:  GOTO   16F
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0164:  CLRF   5B
0165:  MOVLW  10
0166:  MOVWF  5C
0167:  CALL   0CE
0168:  GOTO   16F
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0169:  MOVLW  01
016A:  MOVWF  5B
016B:  MOVF   56,W
016C:  MOVWF  5C
016D:  CALL   0CE
016E:  GOTO   16F
....................    } 
.................... } 
016F:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
....................  
.................... #use RS232(BAUD=9600,BITS=8,PARITY=N,XMIT=PIN_C6,RCV=PIN_C7,stream=PORT1)  
.................... #USE fast_io(d) 
.................... #USE fast_io(b) 
.................... #USE fast_io(c) 
....................  
.................... char data; 
.................... float voltaje,temper,medicion,batery,l1; 
.................... int16 maximo1, minimo1,media1,maximo2, minimo2,media2,S1,S2,duty=0; 
.................... int Timer2,Poscaler; 
....................  
....................  
.................... void ini_puertos(){ 
.................... set_tris_b(0b0000000);     // pines del puerto b son salidas 
*
00AB:  MOVLW  00
00AC:  BSF    03.5
00AD:  MOVWF  06
.................... set_tris_d(0b11); 
00AE:  MOVLW  03
00AF:  MOVWF  08
.................... set_tris_c(0b10000000); 
00B0:  MOVLW  80
00B1:  MOVWF  07
.................... return; 
.................... } 
00B2:  BCF    03.5
00B3:  BSF    0A.3
00B4:  BCF    0A.4
00B5:  GOTO   282 (RETURN)
....................  
.................... void ini_voltaje(){ 
.................... SETUP_ADC (ADC_CLOCK_INTERNAL); 
*
04EB:  BSF    03.5
04EC:  BCF    1F.6
04ED:  BCF    03.5
04EE:  BSF    1F.6
04EF:  BSF    1F.7
04F0:  BSF    03.5
04F1:  BSF    1F.7
04F2:  BCF    03.5
04F3:  BSF    1F.0
.................... SETUP_ADC_PORTS (ALL_ANALOG); 
04F4:  BSF    03.5
04F5:  BCF    1F.0
04F6:  BCF    1F.1
04F7:  BCF    1F.2
04F8:  BCF    1F.3
.................... lcd_init(); 
04F9:  BCF    03.5
04FA:  CALL   1B6
.................... lcd_putc("\fVoltaje"); 
04FB:  MOVLW  0C
04FC:  BSF    03.6
04FD:  MOVWF  0D
04FE:  MOVLW  00
04FF:  MOVWF  0F
0500:  BCF    03.6
0501:  CALL   170
.................... SET_ADC_CHANNEL(0); 
0502:  MOVLW  00
0503:  MOVWF  78
0504:  MOVF   1F,W
0505:  ANDLW  C7
0506:  IORWF  78,W
0507:  MOVWF  1F
.................... delay_ms(20); 
0508:  MOVLW  14
0509:  MOVWF  57
050A:  CALL   124
.................... batery=READ_ADC(); 
050B:  BSF    1F.2
050C:  BTFSC  1F.2
050D:  GOTO   50C
050E:  MOVF   1E,W
050F:  MOVWF  7A
0510:  BSF    03.5
0511:  MOVF   1E,W
0512:  BCF    03.5
0513:  MOVWF  49
0514:  MOVF   1E,W
0515:  MOVWF  4A
0516:  CALL   226
0517:  MOVF   7A,W
0518:  MOVWF  30
0519:  MOVF   79,W
051A:  MOVWF  2F
051B:  MOVF   78,W
051C:  MOVWF  2E
051D:  MOVF   77,W
051E:  MOVWF  2D
.................... voltaje=5.0*batery/1023.0; 
051F:  CLRF   59
0520:  CLRF   58
0521:  MOVLW  20
0522:  MOVWF  57
0523:  MOVLW  81
0524:  MOVWF  56
0525:  MOVF   30,W
0526:  MOVWF  5D
0527:  MOVF   2F,W
0528:  MOVWF  5C
0529:  MOVF   2E,W
052A:  MOVWF  5B
052B:  MOVF   2D,W
052C:  MOVWF  5A
052D:  CALL   243
052E:  MOVF   77,W
052F:  MOVWF  49
0530:  MOVF   78,W
0531:  MOVWF  4A
0532:  MOVF   79,W
0533:  MOVWF  4B
0534:  MOVF   7A,W
0535:  MOVWF  4C
0536:  MOVF   4C,W
0537:  MOVWF  50
0538:  MOVF   4B,W
0539:  MOVWF  4F
053A:  MOVF   4A,W
053B:  MOVWF  4E
053C:  MOVF   49,W
053D:  MOVWF  4D
053E:  CLRF   54
053F:  MOVLW  C0
0540:  MOVWF  53
0541:  MOVLW  7F
0542:  MOVWF  52
0543:  MOVLW  88
0544:  MOVWF  51
*
060E:  MOVF   7A,W
060F:  MOVWF  24
0610:  MOVF   79,W
0611:  MOVWF  23
0612:  MOVF   78,W
0613:  MOVWF  22
0614:  MOVF   77,W
0615:  MOVWF  21
.................... lcd_gotoxy(3,2); 
0616:  MOVLW  03
0617:  MOVWF  57
0618:  MOVLW  02
0619:  MOVWF  58
061A:  CALL   139
.................... printf(lcd_putc, "Valor:%fV   ",voltaje); 
061B:  MOVLW  11
061C:  BSF    03.6
061D:  MOVWF  0D
061E:  MOVLW  00
061F:  MOVWF  0F
0620:  BCF    03.0
0621:  MOVLW  06
0622:  BCF    03.6
0623:  MOVWF  49
0624:  CALL   49D
0625:  MOVLW  89
0626:  MOVWF  04
0627:  MOVF   24,W
0628:  MOVWF  4C
0629:  MOVF   23,W
062A:  MOVWF  4B
062B:  MOVF   22,W
062C:  MOVWF  4A
062D:  MOVF   21,W
062E:  MOVWF  49
062F:  MOVLW  02
0630:  MOVWF  4D
0631:  CALL   2FA
0632:  MOVLW  15
0633:  BSF    03.6
0634:  MOVWF  0D
0635:  MOVLW  00
0636:  MOVWF  0F
0637:  BCF    03.0
0638:  MOVLW  04
0639:  BCF    03.6
063A:  MOVWF  49
063B:  CALL   49D
.................... delay_ms(1500); 
063C:  MOVLW  06
063D:  MOVWF  49
063E:  MOVLW  FA
063F:  MOVWF  57
0640:  CALL   124
0641:  DECFSZ 49,F
0642:  GOTO   63E
.................... } 
0643:  BSF    0A.3
0644:  BCF    0A.4
0645:  GOTO   2CB (RETURN)
....................  
....................  
....................  
....................  
.................... void ini_robot(){ 
....................   
.................... lcd_putc("\f");                                    // Inicia LCD 
*
0800:  MOVLW  18
0801:  BSF    03.6
0802:  MOVWF  0D
0803:  MOVLW  00
0804:  MOVWF  0F
0805:  BCF    0A.3
0806:  BCF    03.6
0807:  CALL   170
0808:  BSF    0A.3
.................... lcd_putc(" Calibrar \n"); 
0809:  MOVLW  19
080A:  BSF    03.6
080B:  MOVWF  0D
080C:  MOVLW  00
080D:  MOVWF  0F
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   170
0811:  BSF    0A.3
.................... lcd_putc(" sensores");        
0812:  MOVLW  1F
0813:  BSF    03.6
0814:  MOVWF  0D
0815:  MOVLW  00
0816:  MOVWF  0F
0817:  BCF    0A.3
0818:  BCF    03.6
0819:  CALL   170
081A:  BSF    0A.3
.................... delay_ms(2000); 
081B:  MOVLW  08
081C:  MOVWF  49
081D:  MOVLW  FA
081E:  MOVWF  57
081F:  BCF    0A.3
0820:  CALL   124
0821:  BSF    0A.3
0822:  DECFSZ 49,F
0823:  GOTO   01D
.................... lcd_putc("\f");                             // Limpia pantalllcd_init();  
0824:  MOVLW  24
0825:  BSF    03.6
0826:  MOVWF  0D
0827:  MOVLW  00
0828:  MOVWF  0F
0829:  BCF    0A.3
082A:  BCF    03.6
082B:  CALL   170
082C:  BSF    0A.3
.................... lcd_putc("maxS1:\n"); 
082D:  MOVLW  25
082E:  BSF    03.6
082F:  MOVWF  0D
0830:  MOVLW  00
0831:  MOVWF  0F
0832:  BCF    0A.3
0833:  BCF    03.6
0834:  CALL   170
0835:  BSF    0A.3
.................... lcd_putc("maxS2:"); 
0836:  MOVLW  29
0837:  BSF    03.6
0838:  MOVWF  0D
0839:  MOVLW  00
083A:  MOVWF  0F
083B:  BCF    0A.3
083C:  BCF    03.6
083D:  CALL   170
083E:  BSF    0A.3
.................... delay_ms(1000);  
083F:  MOVLW  04
0840:  MOVWF  49
0841:  MOVLW  FA
0842:  MOVWF  57
0843:  BCF    0A.3
0844:  CALL   124
0845:  BSF    0A.3
0846:  DECFSZ 49,F
0847:  GOTO   041
.................... lcd_gotoxy(8,1);      // Acomoda cursor LCD 
0848:  MOVLW  08
0849:  MOVWF  57
084A:  MOVLW  01
084B:  MOVWF  58
084C:  BCF    0A.3
084D:  CALL   139
084E:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
084F:  MOVLW  2D
0850:  BSF    03.6
0851:  MOVWF  0D
0852:  MOVLW  00
0853:  MOVWF  0F
0854:  BCF    0A.3
0855:  BCF    03.6
0856:  CALL   170
0857:  BSF    0A.3
.................... lcd_gotoxy(8,1);     // Acomoda cursor LCD 
0858:  MOVLW  08
0859:  MOVWF  57
085A:  MOVLW  01
085B:  MOVWF  58
085C:  BCF    0A.3
085D:  CALL   139
085E:  BSF    0A.3
.................... setup_adc (adc_clock_internal); 
085F:  BSF    03.5
0860:  BCF    1F.6
0861:  BCF    03.5
0862:  BSF    1F.6
0863:  BSF    1F.7
0864:  BSF    03.5
0865:  BSF    1F.7
0866:  BCF    03.5
0867:  BSF    1F.0
.................... setup_adc_ports (all_analog); 
0868:  BSF    03.5
0869:  BCF    1F.0
086A:  BCF    1F.1
086B:  BCF    1F.2
086C:  BCF    1F.3
.................... set_adc_channel (6);               // Elige canal a medir RA1 
086D:  MOVLW  30
086E:  MOVWF  78
086F:  BCF    03.5
0870:  MOVF   1F,W
0871:  ANDLW  C7
0872:  IORWF  78,W
0873:  MOVWF  1F
.................... delay_us (20); 
0874:  MOVLW  06
0875:  MOVWF  77
0876:  DECFSZ 77,F
0877:  GOTO   076
0878:  NOP
.................... maximo1=read_adc ();   // Hace conversión AD  
0879:  BSF    1F.2
087A:  BTFSC  1F.2
087B:  GOTO   07A
087C:  BSF    03.5
087D:  MOVF   1E,W
087E:  BCF    03.5
087F:  MOVWF  35
0880:  MOVF   1E,W
0881:  MOVWF  36
.................... setup_adc (adc_off);                 // Apaga ADC 
0882:  BCF    1F.0
.................... printf(lcd_putc,"%4Ld ",maximo1);   // xxx.x °C 
0883:  MOVLW  02
0884:  MOVWF  04
0885:  MOVF   36,W
0886:  MOVWF  4A
0887:  MOVF   35,W
0888:  MOVWF  49
0889:  BCF    0A.3
088A:  CALL   646
088B:  BSF    0A.3
088C:  MOVLW  20
088D:  MOVWF  56
088E:  BCF    0A.3
088F:  CALL   14B
0890:  BSF    0A.3
.................... delay_ms (2000);  
0891:  MOVLW  08
0892:  MOVWF  49
0893:  MOVLW  FA
0894:  MOVWF  57
0895:  BCF    0A.3
0896:  CALL   124
0897:  BSF    0A.3
0898:  DECFSZ 49,F
0899:  GOTO   093
.................... lcd_gotoxy(8,2);      // Acomoda cursor LCD 
089A:  MOVLW  08
089B:  MOVWF  57
089C:  MOVLW  02
089D:  MOVWF  58
089E:  BCF    0A.3
089F:  CALL   139
08A0:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
08A1:  MOVLW  2F
08A2:  BSF    03.6
08A3:  MOVWF  0D
08A4:  MOVLW  00
08A5:  MOVWF  0F
08A6:  BCF    0A.3
08A7:  BCF    03.6
08A8:  CALL   170
08A9:  BSF    0A.3
.................... lcd_gotoxy(8,2);     // Acomoda cursor LCD 
08AA:  MOVLW  08
08AB:  MOVWF  57
08AC:  MOVLW  02
08AD:  MOVWF  58
08AE:  BCF    0A.3
08AF:  CALL   139
08B0:  BSF    0A.3
.................... setup_adc (adc_clock_internal); 
08B1:  BSF    03.5
08B2:  BCF    1F.6
08B3:  BCF    03.5
08B4:  BSF    1F.6
08B5:  BSF    1F.7
08B6:  BSF    03.5
08B7:  BSF    1F.7
08B8:  BCF    03.5
08B9:  BSF    1F.0
.................... setup_adc_ports (all_analog); 
08BA:  BSF    03.5
08BB:  BCF    1F.0
08BC:  BCF    1F.1
08BD:  BCF    1F.2
08BE:  BCF    1F.3
.................... set_adc_channel (1);               // Elige canal a medir RA2 
08BF:  MOVLW  08
08C0:  MOVWF  78
08C1:  BCF    03.5
08C2:  MOVF   1F,W
08C3:  ANDLW  C7
08C4:  IORWF  78,W
08C5:  MOVWF  1F
.................... delay_us (20); 
08C6:  MOVLW  06
08C7:  MOVWF  77
08C8:  DECFSZ 77,F
08C9:  GOTO   0C8
08CA:  NOP
.................... maximo2=read_adc ();   // Hace conversión AD  
08CB:  BSF    1F.2
08CC:  BTFSC  1F.2
08CD:  GOTO   0CC
08CE:  BSF    03.5
08CF:  MOVF   1E,W
08D0:  BCF    03.5
08D1:  MOVWF  3B
08D2:  MOVF   1E,W
08D3:  MOVWF  3C
.................... setup_adc (adc_off);                 // Apaga ADC 
08D4:  BCF    1F.0
.................... printf(lcd_putc,"%4Ld ",maximo2);   // xxx.x °C 
08D5:  MOVLW  02
08D6:  MOVWF  04
08D7:  MOVF   3C,W
08D8:  MOVWF  4A
08D9:  MOVF   3B,W
08DA:  MOVWF  49
08DB:  BCF    0A.3
08DC:  CALL   646
08DD:  BSF    0A.3
08DE:  MOVLW  20
08DF:  MOVWF  56
08E0:  BCF    0A.3
08E1:  CALL   14B
08E2:  BSF    0A.3
.................... delay_ms (2000); 
08E3:  MOVLW  08
08E4:  MOVWF  49
08E5:  MOVLW  FA
08E6:  MOVWF  57
08E7:  BCF    0A.3
08E8:  CALL   124
08E9:  BSF    0A.3
08EA:  DECFSZ 49,F
08EB:  GOTO   0E5
.................... lcd_putc("\f");  
08EC:  MOVLW  31
08ED:  BSF    03.6
08EE:  MOVWF  0D
08EF:  MOVLW  00
08F0:  MOVWF  0F
08F1:  BCF    0A.3
08F2:  BCF    03.6
08F3:  CALL   170
08F4:  BSF    0A.3
....................  
....................  
.................... ////////minimossss 
....................  
....................  
.................... lcd_putc("\f");                             // Limpia pantalllcd_init();  
08F5:  MOVLW  32
08F6:  BSF    03.6
08F7:  MOVWF  0D
08F8:  MOVLW  00
08F9:  MOVWF  0F
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   170
08FD:  BSF    0A.3
.................... lcd_putc("minS1:\n"); 
08FE:  MOVLW  33
08FF:  BSF    03.6
0900:  MOVWF  0D
0901:  MOVLW  00
0902:  MOVWF  0F
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   170
0906:  BSF    0A.3
.................... lcd_putc("minS2:"); 
0907:  MOVLW  37
0908:  BSF    03.6
0909:  MOVWF  0D
090A:  MOVLW  00
090B:  MOVWF  0F
090C:  BCF    0A.3
090D:  BCF    03.6
090E:  CALL   170
090F:  BSF    0A.3
.................... delay_ms(1000);  
0910:  MOVLW  04
0911:  MOVWF  49
0912:  MOVLW  FA
0913:  MOVWF  57
0914:  BCF    0A.3
0915:  CALL   124
0916:  BSF    0A.3
0917:  DECFSZ 49,F
0918:  GOTO   112
.................... lcd_gotoxy(8,1);      // Acomoda cursor LCD 
0919:  MOVLW  08
091A:  MOVWF  57
091B:  MOVLW  01
091C:  MOVWF  58
091D:  BCF    0A.3
091E:  CALL   139
091F:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
0920:  MOVLW  3B
0921:  BSF    03.6
0922:  MOVWF  0D
0923:  MOVLW  00
0924:  MOVWF  0F
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   170
0928:  BSF    0A.3
.................... lcd_gotoxy(8,1);     // Acomoda cursor LCD 
0929:  MOVLW  08
092A:  MOVWF  57
092B:  MOVLW  01
092C:  MOVWF  58
092D:  BCF    0A.3
092E:  CALL   139
092F:  BSF    0A.3
.................... setup_adc (adc_clock_internal); 
0930:  BSF    03.5
0931:  BCF    1F.6
0932:  BCF    03.5
0933:  BSF    1F.6
0934:  BSF    1F.7
0935:  BSF    03.5
0936:  BSF    1F.7
0937:  BCF    03.5
0938:  BSF    1F.0
.................... setup_adc_ports (all_analog); 
0939:  BSF    03.5
093A:  BCF    1F.0
093B:  BCF    1F.1
093C:  BCF    1F.2
093D:  BCF    1F.3
.................... set_adc_channel (1);               // Elige canal a medir RA1 
093E:  MOVLW  08
093F:  MOVWF  78
0940:  BCF    03.5
0941:  MOVF   1F,W
0942:  ANDLW  C7
0943:  IORWF  78,W
0944:  MOVWF  1F
.................... delay_us (20); 
0945:  MOVLW  06
0946:  MOVWF  77
0947:  DECFSZ 77,F
0948:  GOTO   147
0949:  NOP
.................... minimo1=read_adc ();   // Hace conversión AD  
094A:  BSF    1F.2
094B:  BTFSC  1F.2
094C:  GOTO   14B
094D:  BSF    03.5
094E:  MOVF   1E,W
094F:  BCF    03.5
0950:  MOVWF  37
0951:  MOVF   1E,W
0952:  MOVWF  38
.................... setup_adc (adc_off);                 // Apaga ADC 
0953:  BCF    1F.0
.................... printf(lcd_putc,"%4Ld ",minimo1);   // xxx.x °C 
0954:  MOVLW  02
0955:  MOVWF  04
0956:  MOVF   38,W
0957:  MOVWF  4A
0958:  MOVF   37,W
0959:  MOVWF  49
095A:  BCF    0A.3
095B:  CALL   646
095C:  BSF    0A.3
095D:  MOVLW  20
095E:  MOVWF  56
095F:  BCF    0A.3
0960:  CALL   14B
0961:  BSF    0A.3
.................... delay_ms (2000);  
0962:  MOVLW  08
0963:  MOVWF  49
0964:  MOVLW  FA
0965:  MOVWF  57
0966:  BCF    0A.3
0967:  CALL   124
0968:  BSF    0A.3
0969:  DECFSZ 49,F
096A:  GOTO   164
.................... lcd_gotoxy(8,2);      // Acomoda cursor LCD 
096B:  MOVLW  08
096C:  MOVWF  57
096D:  MOVLW  02
096E:  MOVWF  58
096F:  BCF    0A.3
0970:  CALL   139
0971:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
0972:  MOVLW  3D
0973:  BSF    03.6
0974:  MOVWF  0D
0975:  MOVLW  00
0976:  MOVWF  0F
0977:  BCF    0A.3
0978:  BCF    03.6
0979:  CALL   170
097A:  BSF    0A.3
.................... lcd_gotoxy(8,2);     // Acomoda cursor LCD 
097B:  MOVLW  08
097C:  MOVWF  57
097D:  MOVLW  02
097E:  MOVWF  58
097F:  BCF    0A.3
0980:  CALL   139
0981:  BSF    0A.3
.................... setup_adc (adc_clock_internal); 
0982:  BSF    03.5
0983:  BCF    1F.6
0984:  BCF    03.5
0985:  BSF    1F.6
0986:  BSF    1F.7
0987:  BSF    03.5
0988:  BSF    1F.7
0989:  BCF    03.5
098A:  BSF    1F.0
.................... setup_adc_ports (all_analog); 
098B:  BSF    03.5
098C:  BCF    1F.0
098D:  BCF    1F.1
098E:  BCF    1F.2
098F:  BCF    1F.3
.................... set_adc_channel (1);               // Elige canal a medir RA2 
0990:  MOVLW  08
0991:  MOVWF  78
0992:  BCF    03.5
0993:  MOVF   1F,W
0994:  ANDLW  C7
0995:  IORWF  78,W
0996:  MOVWF  1F
.................... delay_us (20); 
0997:  MOVLW  06
0998:  MOVWF  77
0999:  DECFSZ 77,F
099A:  GOTO   199
099B:  NOP
.................... minimo2=read_adc ();   // Hace conversión AD  
099C:  BSF    1F.2
099D:  BTFSC  1F.2
099E:  GOTO   19D
099F:  BSF    03.5
09A0:  MOVF   1E,W
09A1:  BCF    03.5
09A2:  MOVWF  3D
09A3:  MOVF   1E,W
09A4:  MOVWF  3E
.................... setup_adc (adc_off);                 // Apaga ADC 
09A5:  BCF    1F.0
.................... printf(lcd_putc,"%4Ld ",minimo2);   // xxx.x °C 
09A6:  MOVLW  02
09A7:  MOVWF  04
09A8:  MOVF   3E,W
09A9:  MOVWF  4A
09AA:  MOVF   3D,W
09AB:  MOVWF  49
09AC:  BCF    0A.3
09AD:  CALL   646
09AE:  BSF    0A.3
09AF:  MOVLW  20
09B0:  MOVWF  56
09B1:  BCF    0A.3
09B2:  CALL   14B
09B3:  BSF    0A.3
.................... delay_ms (2000); 
09B4:  MOVLW  08
09B5:  MOVWF  49
09B6:  MOVLW  FA
09B7:  MOVWF  57
09B8:  BCF    0A.3
09B9:  CALL   124
09BA:  BSF    0A.3
09BB:  DECFSZ 49,F
09BC:  GOTO   1B6
.................... lcd_putc("\f"); 
09BD:  MOVLW  3F
09BE:  BSF    03.6
09BF:  MOVWF  0D
09C0:  MOVLW  00
09C1:  MOVWF  0F
09C2:  BCF    0A.3
09C3:  BCF    03.6
09C4:  CALL   170
09C5:  BSF    0A.3
....................  
.................... //////7 promedio 
....................  
....................  
.................... lcd_putc("media1:\n"); 
09C6:  MOVLW  40
09C7:  BSF    03.6
09C8:  MOVWF  0D
09C9:  MOVLW  00
09CA:  MOVWF  0F
09CB:  BCF    0A.3
09CC:  BCF    03.6
09CD:  CALL   170
09CE:  BSF    0A.3
.................... lcd_putc("media2:"); 
09CF:  MOVLW  45
09D0:  BSF    03.6
09D1:  MOVWF  0D
09D2:  MOVLW  00
09D3:  MOVWF  0F
09D4:  BCF    0A.3
09D5:  BCF    03.6
09D6:  CALL   170
09D7:  BSF    0A.3
.................... delay_ms(1000);  
09D8:  MOVLW  04
09D9:  MOVWF  49
09DA:  MOVLW  FA
09DB:  MOVWF  57
09DC:  BCF    0A.3
09DD:  CALL   124
09DE:  BSF    0A.3
09DF:  DECFSZ 49,F
09E0:  GOTO   1DA
.................... lcd_gotoxy(8,1);      // Acomoda cursor LCD 
09E1:  MOVLW  08
09E2:  MOVWF  57
09E3:  MOVLW  01
09E4:  MOVWF  58
09E5:  BCF    0A.3
09E6:  CALL   139
09E7:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
09E8:  MOVLW  49
09E9:  BSF    03.6
09EA:  MOVWF  0D
09EB:  MOVLW  00
09EC:  MOVWF  0F
09ED:  BCF    0A.3
09EE:  BCF    03.6
09EF:  CALL   170
09F0:  BSF    0A.3
.................... lcd_gotoxy(8,1);     // Acomoda cursor LCD 
09F1:  MOVLW  08
09F2:  MOVWF  57
09F3:  MOVLW  01
09F4:  MOVWF  58
09F5:  BCF    0A.3
09F6:  CALL   139
09F7:  BSF    0A.3
.................... media1=(maximo1-minimo1)/2 ;   // Hace conversión AD  
09F8:  MOVF   37,W
09F9:  SUBWF  35,W
09FA:  MOVWF  49
09FB:  MOVF   36,W
09FC:  MOVWF  4A
09FD:  MOVF   38,W
09FE:  BTFSS  03.0
09FF:  INCFSZ 38,W
0A00:  SUBWF  4A,F
0A01:  BCF    03.0
0A02:  RRF    4A,W
0A03:  MOVWF  3A
0A04:  RRF    49,W
0A05:  MOVWF  39
....................  
.................... printf(lcd_putc,"%4Ld ",media1);   // xxx.x °C 
0A06:  MOVLW  02
0A07:  MOVWF  04
0A08:  MOVF   3A,W
0A09:  MOVWF  4A
0A0A:  MOVF   39,W
0A0B:  MOVWF  49
0A0C:  BCF    0A.3
0A0D:  CALL   646
0A0E:  BSF    0A.3
0A0F:  MOVLW  20
0A10:  MOVWF  56
0A11:  BCF    0A.3
0A12:  CALL   14B
0A13:  BSF    0A.3
.................... delay_ms (2000);  
0A14:  MOVLW  08
0A15:  MOVWF  49
0A16:  MOVLW  FA
0A17:  MOVWF  57
0A18:  BCF    0A.3
0A19:  CALL   124
0A1A:  BSF    0A.3
0A1B:  DECFSZ 49,F
0A1C:  GOTO   216
.................... lcd_gotoxy(8,2);      // Acomoda cursor LCD 
0A1D:  MOVLW  08
0A1E:  MOVWF  57
0A1F:  MOVLW  02
0A20:  MOVWF  58
0A21:  BCF    0A.3
0A22:  CALL   139
0A23:  BSF    0A.3
.................... lcd_putc("   ");       // Limpia ese sector de pantalla 
0A24:  MOVLW  4B
0A25:  BSF    03.6
0A26:  MOVWF  0D
0A27:  MOVLW  00
0A28:  MOVWF  0F
0A29:  BCF    0A.3
0A2A:  BCF    03.6
0A2B:  CALL   170
0A2C:  BSF    0A.3
.................... lcd_gotoxy(8,2);     // Acomoda cursor LCD 
0A2D:  MOVLW  08
0A2E:  MOVWF  57
0A2F:  MOVLW  02
0A30:  MOVWF  58
0A31:  BCF    0A.3
0A32:  CALL   139
0A33:  BSF    0A.3
.................... delay_us (20); 
0A34:  MOVLW  06
0A35:  MOVWF  77
0A36:  DECFSZ 77,F
0A37:  GOTO   236
0A38:  NOP
.................... media2=(maximo2-minimo2)/2;   // Hace conversión AD  
0A39:  MOVF   3D,W
0A3A:  SUBWF  3B,W
0A3B:  MOVWF  49
0A3C:  MOVF   3C,W
0A3D:  MOVWF  4A
0A3E:  MOVF   3E,W
0A3F:  BTFSS  03.0
0A40:  INCFSZ 3E,W
0A41:  SUBWF  4A,F
0A42:  BCF    03.0
0A43:  RRF    4A,W
0A44:  MOVWF  40
0A45:  RRF    49,W
0A46:  MOVWF  3F
.................... printf(lcd_putc,"%4Ld ",media2); 
0A47:  MOVLW  02
0A48:  MOVWF  04
0A49:  MOVF   40,W
0A4A:  MOVWF  4A
0A4B:  MOVF   3F,W
0A4C:  MOVWF  49
0A4D:  BCF    0A.3
0A4E:  CALL   646
0A4F:  BSF    0A.3
0A50:  MOVLW  20
0A51:  MOVWF  56
0A52:  BCF    0A.3
0A53:  CALL   14B
0A54:  BSF    0A.3
.................... delay_ms(2000); 
0A55:  MOVLW  08
0A56:  MOVWF  49
0A57:  MOVLW  FA
0A58:  MOVWF  57
0A59:  BCF    0A.3
0A5A:  CALL   124
0A5B:  BSF    0A.3
0A5C:  DECFSZ 49,F
0A5D:  GOTO   257
.................... lcd_putc("\f"); 
0A5E:  MOVLW  4D
0A5F:  BSF    03.6
0A60:  MOVWF  0D
0A61:  MOVLW  00
0A62:  MOVWF  0F
0A63:  BCF    0A.3
0A64:  BCF    03.6
0A65:  CALL   170
0A66:  BSF    0A.3
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... return; 
.................... } 
0A67:  BSF    0A.3
0A68:  BCF    0A.4
0A69:  GOTO   2CF (RETURN)
.................... void ini_lcd(){ 
.................... lcd_init(); // Inicialzacón de la LCD 
*
01ED:  CALL   1B6
.................... lcd_gotoxy(1,1); 
01EE:  MOVLW  01
01EF:  MOVWF  57
01F0:  MOVWF  58
01F1:  CALL   139
.................... lcd_putc(" bienvenidos"); 
01F2:  MOVLW  4E
01F3:  BSF    03.6
01F4:  MOVWF  0D
01F5:  MOVLW  00
01F6:  MOVWF  0F
01F7:  BCF    03.6
01F8:  CALL   170
.................... delay_ms(1000); 
01F9:  MOVLW  04
01FA:  MOVWF  49
01FB:  MOVLW  FA
01FC:  MOVWF  57
01FD:  CALL   124
01FE:  DECFSZ 49,F
01FF:  GOTO   1FB
.................... lcd_putc("\f");  
0200:  MOVLW  55
0201:  BSF    03.6
0202:  MOVWF  0D
0203:  MOVLW  00
0204:  MOVWF  0F
0205:  BCF    03.6
0206:  CALL   170
.................... lcd_putc("PRESIONE\n"); 
0207:  MOVLW  56
0208:  BSF    03.6
0209:  MOVWF  0D
020A:  MOVLW  00
020B:  MOVWF  0F
020C:  BCF    03.6
020D:  CALL   170
.................... lcd_putc("UN BOTON"); 
020E:  MOVLW  5B
020F:  BSF    03.6
0210:  MOVWF  0D
0211:  MOVLW  00
0212:  MOVWF  0F
0213:  BCF    03.6
0214:  CALL   170
.................... delay_ms(2000); 
0215:  MOVLW  08
0216:  MOVWF  49
0217:  MOVLW  FA
0218:  MOVWF  57
0219:  CALL   124
021A:  DECFSZ 49,F
021B:  GOTO   217
.................... lcd_putc("\f");                             // Limpia pantalla 
021C:  MOVLW  60
021D:  BSF    03.6
021E:  MOVWF  0D
021F:  MOVLW  00
0220:  MOVWF  0F
0221:  BCF    03.6
0222:  CALL   170
.................... return; 
.................... } 
0223:  BSF    0A.3
0224:  BCF    0A.4
0225:  GOTO   2A1 (RETURN)
....................  
....................  
.................... void ini_temperatura(){ 
....................  lcd_init(); 
*
03E1:  CALL   1B6
.................... lcd_putc("\f");                                    // Inicia LCD 
03E2:  MOVLW  61
03E3:  BSF    03.6
03E4:  MOVWF  0D
03E5:  MOVLW  00
03E6:  MOVWF  0F
03E7:  BCF    03.6
03E8:  CALL   170
.................... lcd_putc(" Termometro\n");          // Saca texto 
03E9:  MOVLW  62
03EA:  BSF    03.6
03EB:  MOVWF  0D
03EC:  MOVLW  00
03ED:  MOVWF  0F
03EE:  BCF    03.6
03EF:  CALL   170
.................... lcd_putc(" con LM35");               // Saca texto 
03F0:  MOVLW  69
03F1:  BSF    03.6
03F2:  MOVWF  0D
03F3:  MOVLW  00
03F4:  MOVWF  0F
03F5:  BCF    03.6
03F6:  CALL   170
.................... delay_ms(2000); 
03F7:  MOVLW  08
03F8:  MOVWF  49
03F9:  MOVLW  FA
03FA:  MOVWF  57
03FB:  CALL   124
03FC:  DECFSZ 49,F
03FD:  GOTO   3F9
.................... lcd_putc("\f");                             // Limpia pantalla 
03FE:  MOVLW  6E
03FF:  BSF    03.6
0400:  MOVWF  0D
0401:  MOVLW  00
0402:  MOVWF  0F
0403:  BCF    03.6
0404:  CALL   170
.................... lcd_putc("Temperatura\n");          // Saca texto 
0405:  MOVLW  6F
0406:  BSF    03.6
0407:  MOVWF  0D
0408:  MOVLW  00
0409:  MOVWF  0F
040A:  BCF    03.6
040B:  CALL   170
.................... lcd_putc("actual");                      // Saca texto 
040C:  MOVLW  76
040D:  BSF    03.6
040E:  MOVWF  0D
040F:  MOVLW  00
0410:  MOVWF  0F
0411:  BCF    03.6
0412:  CALL   170
.................... delay_ms(1000);  
0413:  MOVLW  04
0414:  MOVWF  49
0415:  MOVLW  FA
0416:  MOVWF  57
0417:  CALL   124
0418:  DECFSZ 49,F
0419:  GOTO   415
.................... lcd_gotoxy(14,2);                       // Acomoda cursor LCD 
041A:  MOVLW  0E
041B:  MOVWF  57
041C:  MOVLW  02
041D:  MOVWF  58
041E:  CALL   139
.................... lcd_putc("oC"); 
041F:  MOVLW  7A
0420:  BSF    03.6
0421:  MOVWF  0D
0422:  MOVLW  00
0423:  MOVWF  0F
0424:  BCF    03.6
0425:  CALL   170
.................... lcd_gotoxy(8,2);      // Acomoda cursor LCD 
0426:  MOVLW  08
0427:  MOVWF  57
0428:  MOVLW  02
0429:  MOVWF  58
042A:  CALL   139
.................... lcd_putc(" ");          // Limpia ese sector de pantalla 
042B:  MOVLW  7C
042C:  BSF    03.6
042D:  MOVWF  0D
042E:  MOVLW  00
042F:  MOVWF  0F
0430:  BCF    03.6
0431:  CALL   170
.................... lcd_gotoxy(8,2);     // Acomoda cursor LCD 
0432:  MOVLW  08
0433:  MOVWF  57
0434:  MOVLW  02
0435:  MOVWF  58
0436:  CALL   139
.................... setup_adc (adc_clock_internal); 
0437:  BSF    03.5
0438:  BCF    1F.6
0439:  BCF    03.5
043A:  BSF    1F.6
043B:  BSF    1F.7
043C:  BSF    03.5
043D:  BSF    1F.7
043E:  BCF    03.5
043F:  BSF    1F.0
.................... setup_adc_ports (all_analog); 
0440:  BSF    03.5
0441:  BCF    1F.0
0442:  BCF    1F.1
0443:  BCF    1F.2
0444:  BCF    1F.3
.................... set_adc_channel (4);                // Elige canal a medir RA0 
0445:  MOVLW  20
0446:  MOVWF  78
0447:  BCF    03.5
0448:  MOVF   1F,W
0449:  ANDLW  C7
044A:  IORWF  78,W
044B:  MOVWF  1F
.................... delay_us (20); 
044C:  MOVLW  06
044D:  MOVWF  77
044E:  DECFSZ 77,F
044F:  GOTO   44E
0450:  NOP
.................... medicion=read_adc ();              // Hace conversión AD  
0451:  BSF    1F.2
0452:  BTFSC  1F.2
0453:  GOTO   452
0454:  MOVF   1E,W
0455:  MOVWF  7A
0456:  BSF    03.5
0457:  MOVF   1E,W
0458:  BCF    03.5
0459:  MOVWF  49
045A:  MOVF   1E,W
045B:  MOVWF  4A
045C:  CALL   226
045D:  MOVF   7A,W
045E:  MOVWF  2C
045F:  MOVF   79,W
0460:  MOVWF  2B
0461:  MOVF   78,W
0462:  MOVWF  2A
0463:  MOVF   77,W
0464:  MOVWF  29
.................... setup_adc (adc_off);                 // Apaga ADC 
0465:  BCF    1F.0
.................... temper=medicion*(0.48875);     // Pasa binario a °C  
0466:  MOVF   2C,W
0467:  MOVWF  59
0468:  MOVF   2B,W
0469:  MOVWF  58
046A:  MOVF   2A,W
046B:  MOVWF  57
046C:  MOVF   29,W
046D:  MOVWF  56
046E:  MOVLW  71
046F:  MOVWF  5D
0470:  MOVLW  3D
0471:  MOVWF  5C
0472:  MOVLW  7A
0473:  MOVWF  5B
0474:  MOVLW  7D
0475:  MOVWF  5A
0476:  CALL   243
0477:  MOVF   7A,W
0478:  MOVWF  28
0479:  MOVF   79,W
047A:  MOVWF  27
047B:  MOVF   78,W
047C:  MOVWF  26
047D:  MOVF   77,W
047E:  MOVWF  25
.................... printf(lcd_putc,"%02.1f",temper);   // xxx.x °C 
047F:  MOVLW  41
0480:  MOVWF  04
0481:  MOVF   28,W
0482:  MOVWF  4C
0483:  MOVF   27,W
0484:  MOVWF  4B
0485:  MOVF   26,W
0486:  MOVWF  4A
0487:  MOVF   25,W
0488:  MOVWF  49
0489:  MOVLW  01
048A:  MOVWF  4D
048B:  CALL   2FA
.................... delay_ms (3000); 
048C:  MOVLW  0C
048D:  MOVWF  49
048E:  MOVLW  FA
048F:  MOVWF  57
0490:  CALL   124
0491:  DECFSZ 49,F
0492:  GOTO   48E
.................... lcd_putc("\f");  
0493:  MOVLW  7D
0494:  BSF    03.6
0495:  MOVWF  0D
0496:  MOVLW  00
0497:  MOVWF  0F
0498:  BCF    03.6
0499:  CALL   170
.................... return; 
.................... } 
049A:  BSF    0A.3
049B:  BCF    0A.4
049C:  GOTO   2C3 (RETURN)
....................  
....................  
.................... void main(){ 
*
0A6A:  CLRF   04
0A6B:  BCF    03.7
0A6C:  MOVLW  1F
0A6D:  ANDWF  03,F
0A6E:  MOVLW  19
0A6F:  BSF    03.5
0A70:  MOVWF  19
0A71:  MOVLW  A6
0A72:  MOVWF  18
0A73:  MOVLW  90
0A74:  BCF    03.5
0A75:  MOVWF  18
0A76:  CLRF   46
0A77:  CLRF   45
0A78:  BSF    03.5
0A79:  BSF    1F.0
0A7A:  BSF    1F.1
0A7B:  BSF    1F.2
0A7C:  BCF    1F.3
0A7D:  MOVLW  07
0A7E:  MOVWF  1C
.................... ini_puertos(); 
0A7F:  BCF    0A.3
0A80:  BCF    03.5
0A81:  GOTO   0AB
0A82:  BSF    0A.3
.................... lcd_putc("puertos ok");  
0A83:  MOVLW  7E
0A84:  BSF    03.6
0A85:  MOVWF  0D
0A86:  MOVLW  00
0A87:  MOVWF  0F
0A88:  BCF    0A.3
0A89:  BCF    03.6
0A8A:  CALL   170
0A8B:  BSF    0A.3
.................... delay_ms(2000); 
0A8C:  MOVLW  08
0A8D:  MOVWF  49
0A8E:  MOVLW  FA
0A8F:  MOVWF  57
0A90:  BCF    0A.3
0A91:  CALL   124
0A92:  BSF    0A.3
0A93:  DECFSZ 49,F
0A94:  GOTO   28E
.................... lcd_putc("\f"); 
0A95:  MOVLW  84
0A96:  BSF    03.6
0A97:  MOVWF  0D
0A98:  MOVLW  00
0A99:  MOVWF  0F
0A9A:  BCF    0A.3
0A9B:  BCF    03.6
0A9C:  CALL   170
0A9D:  BSF    0A.3
.................... output_b(0b00000000);                              ///PWM 
0A9E:  CLRF   06
....................  
....................  
....................  
....................  
.................... ini_lcd(); 
0A9F:  BCF    0A.3
0AA0:  GOTO   1ED
0AA1:  BSF    0A.3
.................... delay_ms(20); 
0AA2:  MOVLW  14
0AA3:  MOVWF  57
0AA4:  BCF    0A.3
0AA5:  CALL   124
0AA6:  BSF    0A.3
.................... lcd_gotoxy(1,1); 
0AA7:  MOVLW  01
0AA8:  MOVWF  57
0AA9:  MOVWF  58
0AAA:  BCF    0A.3
0AAB:  CALL   139
0AAC:  BSF    0A.3
.................... lcd_putc("Temp(1) VOLT(3)\n"); 
0AAD:  MOVLW  85
0AAE:  BSF    03.6
0AAF:  MOVWF  0D
0AB0:  MOVLW  00
0AB1:  MOVWF  0F
0AB2:  BCF    0A.3
0AB3:  BCF    03.6
0AB4:  CALL   170
0AB5:  BSF    0A.3
.................... lcd_putc("SENSORES(2)");        // Saca texto 
0AB6:  MOVLW  8E
0AB7:  BSF    03.6
0AB8:  MOVWF  0D
0AB9:  MOVLW  00
0ABA:  MOVWF  0F
0ABB:  BCF    0A.3
0ABC:  BCF    03.6
0ABD:  CALL   170
0ABE:  BSF    0A.3
.................... while(true){ 
.................... if(INPUT(PIN_D0)==1){ 
0ABF:  BTFSS  08.0
0AC0:  GOTO   2C4
.................... ini_temperatura(); 
0AC1:  BCF    0A.3
0AC2:  GOTO   3E1
0AC3:  BSF    0A.3
.................... } 
.................... if (INPUT(PIN_E2)==1){ 
0AC4:  BSF    03.5
0AC5:  BSF    09.2
0AC6:  BCF    03.5
0AC7:  BTFSS  09.2
0AC8:  GOTO   2CC
.................... ini_voltaje(); 
0AC9:  BCF    0A.3
0ACA:  GOTO   4EB
0ACB:  BSF    0A.3
.................... } 
.................... if (INPUT(PIN_D1)==1){ 
0ACC:  BTFSS  08.1
0ACD:  GOTO   415
.................... ini_robot(); 
0ACE:  GOTO   000
.................... data=getc(); 
0ACF:  BTFSS  0C.5
0AD0:  GOTO   2CF
0AD1:  MOVF   1A,W
0AD2:  MOVWF  20
....................  
....................    while(1){ 
....................    Timer2=255; 
0AD3:  MOVLW  FF
0AD4:  MOVWF  47
....................    Poscaler=1; 
0AD5:  MOVLW  01
0AD6:  MOVWF  48
....................    setup_timer_2(t2_div_by_4,Timer2,Poscaler);      //100% FULL HD 
0AD7:  SUBWF  48,W
0AD8:  MOVWF  78
0AD9:  RLF    78,W
0ADA:  MOVWF  77
0ADB:  RLF    77,F
0ADC:  RLF    77,F
0ADD:  MOVLW  F8
0ADE:  ANDWF  77,F
0ADF:  MOVF   77,W
0AE0:  IORLW  05
0AE1:  MOVWF  12
0AE2:  MOVF   47,W
0AE3:  BSF    03.5
0AE4:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
0AE5:  BCF    03.5
0AE6:  BCF    07.2
0AE7:  MOVLW  0C
0AE8:  MOVWF  17
....................    duty=800; 
0AE9:  MOVLW  03
0AEA:  MOVWF  46
0AEB:  MOVLW  20
0AEC:  MOVWF  45
....................    set_pwm1_duty(duty); 
0AED:  MOVF   46,W
0AEE:  MOVWF  79
0AEF:  MOVF   45,W
0AF0:  MOVWF  78
0AF1:  RRF    79,F
0AF2:  RRF    78,F
0AF3:  RRF    79,F
0AF4:  RRF    78,F
0AF5:  RRF    79,F
0AF6:  MOVF   78,W
0AF7:  MOVWF  15
0AF8:  RRF    79,F
0AF9:  RRF    79,W
0AFA:  ANDLW  30
0AFB:  MOVWF  77
0AFC:  MOVF   17,W
0AFD:  ANDLW  CF
0AFE:  IORWF  77,W
0AFF:  MOVWF  17
....................    set_pwm2_duty(duty); 
0B00:  MOVF   46,W
0B01:  MOVWF  79
0B02:  MOVF   45,W
0B03:  MOVWF  78
0B04:  RRF    79,F
0B05:  RRF    78,F
0B06:  RRF    79,F
0B07:  RRF    78,F
0B08:  RRF    79,F
0B09:  MOVF   78,W
0B0A:  MOVWF  1B
0B0B:  RRF    79,F
0B0C:  RRF    79,W
0B0D:  ANDLW  30
0B0E:  MOVWF  77
0B0F:  MOVF   1D,W
0B10:  ANDLW  CF
0B11:  IORWF  77,W
0B12:  MOVWF  1D
....................   data=getc();  
0B13:  BTFSS  0C.5
0B14:  GOTO   313
0B15:  MOVF   1A,W
0B16:  MOVWF  20
....................  
....................  if(data=='Z'){ 
0B17:  MOVF   20,W
0B18:  SUBLW  5A
0B19:  BTFSS  03.2
0B1A:  GOTO   34D
....................  Timer2=255; 
0B1B:  MOVLW  FF
0B1C:  MOVWF  47
....................    delay_ms(20); 
0B1D:  MOVLW  14
0B1E:  MOVWF  57
0B1F:  BCF    0A.3
0B20:  CALL   124
0B21:  BSF    0A.3
....................    Poscaler=1; 
0B22:  MOVLW  01
0B23:  MOVWF  48
....................    setup_timer_2(t2_div_by_16,Timer2,Poscaler);      //100% FULL HD 
0B24:  SUBWF  48,W
0B25:  MOVWF  78
0B26:  RLF    78,W
0B27:  MOVWF  77
0B28:  RLF    77,F
0B29:  RLF    77,F
0B2A:  MOVLW  F8
0B2B:  ANDWF  77,F
0B2C:  MOVF   77,W
0B2D:  IORLW  06
0B2E:  MOVWF  12
0B2F:  MOVF   47,W
0B30:  BSF    03.5
0B31:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
0B32:  BCF    03.5
0B33:  BCF    07.2
0B34:  MOVLW  0C
0B35:  MOVWF  17
....................    duty=1023; 
0B36:  MOVLW  03
0B37:  MOVWF  46
0B38:  MOVLW  FF
0B39:  MOVWF  45
....................    set_pwm1_duty(duty); 
0B3A:  MOVF   46,W
0B3B:  MOVWF  79
0B3C:  MOVF   45,W
0B3D:  MOVWF  78
0B3E:  RRF    79,F
0B3F:  RRF    78,F
0B40:  RRF    79,F
0B41:  RRF    78,F
0B42:  RRF    79,F
0B43:  MOVF   78,W
0B44:  MOVWF  15
0B45:  RRF    79,F
0B46:  RRF    79,W
0B47:  ANDLW  30
0B48:  MOVWF  77
0B49:  MOVF   17,W
0B4A:  ANDLW  CF
0B4B:  IORWF  77,W
0B4C:  MOVWF  17
....................   
....................  } 
....................  if(data=='X'){ 
0B4D:  MOVF   20,W
0B4E:  SUBLW  58
0B4F:  BTFSS  03.2
0B50:  GOTO   37E
....................  Timer2=255; 
0B51:  MOVLW  FF
0B52:  MOVWF  47
....................    Poscaler=1; 
0B53:  MOVLW  01
0B54:  MOVWF  48
....................    setup_timer_2(t2_div_by_4,Timer2,Poscaler);      //100% FULL HD 
0B55:  SUBWF  48,W
0B56:  MOVWF  78
0B57:  RLF    78,W
0B58:  MOVWF  77
0B59:  RLF    77,F
0B5A:  RLF    77,F
0B5B:  MOVLW  F8
0B5C:  ANDWF  77,F
0B5D:  MOVF   77,W
0B5E:  IORLW  05
0B5F:  MOVWF  12
0B60:  MOVF   47,W
0B61:  BSF    03.5
0B62:  MOVWF  12
....................    setup_ccp1(ccp_pwm); 
0B63:  BCF    03.5
0B64:  BCF    07.2
0B65:  MOVLW  0C
0B66:  MOVWF  17
....................    duty=1023; 
0B67:  MOVLW  03
0B68:  MOVWF  46
0B69:  MOVLW  FF
0B6A:  MOVWF  45
....................    set_pwm1_duty(duty); 
0B6B:  MOVF   46,W
0B6C:  MOVWF  79
0B6D:  MOVF   45,W
0B6E:  MOVWF  78
0B6F:  RRF    79,F
0B70:  RRF    78,F
0B71:  RRF    79,F
0B72:  RRF    78,F
0B73:  RRF    79,F
0B74:  MOVF   78,W
0B75:  MOVWF  15
0B76:  RRF    79,F
0B77:  RRF    79,W
0B78:  ANDLW  30
0B79:  MOVWF  77
0B7A:  MOVF   17,W
0B7B:  ANDLW  CF
0B7C:  IORWF  77,W
0B7D:  MOVWF  17
....................   
....................  } 
....................    
.................... if(data=='W'){                                    //SE ALMACENA EL VALOR EN DATA, DEL MODULO Y SE INICIA EL MOTOR DEPENDIENDO DE SU VALOR W,S,A,D. 
0B7E:  MOVF   20,W
0B7F:  SUBLW  57
0B80:  BTFSS  03.2
0B81:  GOTO   39C
....................    output_high(PIN_B0); 
0B82:  BSF    06.0
....................    output_low(PIN_B1); 
0B83:  BCF    06.1
....................    output_high(PIN_B2); 
0B84:  BSF    06.2
....................    output_low(PIN_B3); 
0B85:  BCF    06.3
....................    output_high(PIN_B4); 
0B86:  BSF    06.4
....................    output_low(PIN_B5); 
0B87:  BCF    06.5
....................    output_high(PIN_B6); 
0B88:  BSF    06.6
....................    output_low(PIN_B7); 
0B89:  BCF    06.7
....................    lcd_init(); // Inicialzacón de la LCD 
0B8A:  BCF    0A.3
0B8B:  CALL   1B6
0B8C:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0B8D:  MOVLW  01
0B8E:  MOVWF  57
0B8F:  MOVWF  58
0B90:  BCF    0A.3
0B91:  CALL   139
0B92:  BSF    0A.3
....................    lcd_putc(" adelante"); 
0B93:  MOVLW  94
0B94:  BSF    03.6
0B95:  MOVWF  0D
0B96:  MOVLW  00
0B97:  MOVWF  0F
0B98:  BCF    0A.3
0B99:  BCF    03.6
0B9A:  CALL   170
0B9B:  BSF    0A.3
....................     
....................    
....................  
....................   
....................    
....................     
.................... } 
.................... if(data=='S'){                                    //SE ALMACENA EL VALOR EN DATA, DEL MODULO Y SE INICIA EL MOTOR DEPENDIENDO DE SU VALOR W,S,A,D. 
0B9C:  MOVF   20,W
0B9D:  SUBLW  53
0B9E:  BTFSS  03.2
0B9F:  GOTO   3BA
....................    output_low(PIN_B0); 
0BA0:  BCF    06.0
....................    output_high(PIN_B1); 
0BA1:  BSF    06.1
....................    output_low(PIN_B2); 
0BA2:  BCF    06.2
....................    output_high(PIN_B3); 
0BA3:  BSF    06.3
....................    output_low(PIN_B4); 
0BA4:  BCF    06.4
....................    output_high(PIN_B5); 
0BA5:  BSF    06.5
....................    output_low(PIN_B6); 
0BA6:  BCF    06.6
....................    output_high(PIN_B7); 
0BA7:  BSF    06.7
....................    lcd_init(); // Inicialzacón de la LCD 
0BA8:  BCF    0A.3
0BA9:  CALL   1B6
0BAA:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0BAB:  MOVLW  01
0BAC:  MOVWF  57
0BAD:  MOVWF  58
0BAE:  BCF    0A.3
0BAF:  CALL   139
0BB0:  BSF    0A.3
....................    lcd_putc(" atras"); 
0BB1:  MOVLW  99
0BB2:  BSF    03.6
0BB3:  MOVWF  0D
0BB4:  MOVLW  00
0BB5:  MOVWF  0F
0BB6:  BCF    0A.3
0BB7:  BCF    03.6
0BB8:  CALL   170
0BB9:  BSF    0A.3
....................  ; 
....................    } 
.................... if(data=='A'){                                    //SE ALMACENA EL VALOR EN DATA, DEL MODULO Y SE INICIA EL MOTOR DEPENDIENDO DE SU VALOR W,S,A,D. 
0BBA:  MOVF   20,W
0BBB:  SUBLW  41
0BBC:  BTFSS  03.2
0BBD:  GOTO   3D8
....................    output_low(PIN_B0); 
0BBE:  BCF    06.0
....................    output_high(PIN_B1); 
0BBF:  BSF    06.1
....................    output_high(PIN_B2); 
0BC0:  BSF    06.2
....................    output_low(PIN_B3); 
0BC1:  BCF    06.3
....................    output_low(PIN_B4); 
0BC2:  BCF    06.4
....................    output_high(PIN_B5); 
0BC3:  BSF    06.5
....................    output_high(PIN_B6); 
0BC4:  BSF    06.6
....................    output_low(PIN_B7); 
0BC5:  BCF    06.7
....................    lcd_init(); // Inicialzacón de la LCD 
0BC6:  BCF    0A.3
0BC7:  CALL   1B6
0BC8:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0BC9:  MOVLW  01
0BCA:  MOVWF  57
0BCB:  MOVWF  58
0BCC:  BCF    0A.3
0BCD:  CALL   139
0BCE:  BSF    0A.3
....................    lcd_putc(" IZQUIERDA");  
0BCF:  MOVLW  9D
0BD0:  BSF    03.6
0BD1:  MOVWF  0D
0BD2:  MOVLW  00
0BD3:  MOVWF  0F
0BD4:  BCF    0A.3
0BD5:  BCF    03.6
0BD6:  CALL   170
0BD7:  BSF    0A.3
....................  
.................... } 
.................... if(data=='D'){                                    //SE ALMACENA EL VALOR EN DATA, DEL MODULO Y SE INICIA EL MOTOR DEPENDIENDO DE SU VALOR W,S,A,D. 
0BD8:  MOVF   20,W
0BD9:  SUBLW  44
0BDA:  BTFSS  03.2
0BDB:  GOTO   3F6
....................    output_high(PIN_B0); 
0BDC:  BSF    06.0
....................    output_low(PIN_B1); 
0BDD:  BCF    06.1
....................    output_low(PIN_B2); 
0BDE:  BCF    06.2
....................    output_high(PIN_B3); 
0BDF:  BSF    06.3
....................    output_high(PIN_B4); 
0BE0:  BSF    06.4
....................    output_low(PIN_B5); 
0BE1:  BCF    06.5
....................    output_low(PIN_B6); 
0BE2:  BCF    06.6
....................    output_high(PIN_B7); 
0BE3:  BSF    06.7
....................    lcd_init(); // Inicialzacón de la LCD 
0BE4:  BCF    0A.3
0BE5:  CALL   1B6
0BE6:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0BE7:  MOVLW  01
0BE8:  MOVWF  57
0BE9:  MOVWF  58
0BEA:  BCF    0A.3
0BEB:  CALL   139
0BEC:  BSF    0A.3
....................    lcd_putc(" DERECHA");    
0BED:  MOVLW  A3
0BEE:  BSF    03.6
0BEF:  MOVWF  0D
0BF0:  MOVLW  00
0BF1:  MOVWF  0F
0BF2:  BCF    0A.3
0BF3:  BCF    03.6
0BF4:  CALL   170
0BF5:  BSF    0A.3
....................    ; 
.................... } 
.................... if(data=='F'){                                    //SE ALMACENA EL VALOR EN DATA, DEL MODULO Y SE INICIA EL MOTOR DEPENDIENDO DE SU VALOR W,S,A,D. 
0BF6:  MOVF   20,W
0BF7:  SUBLW  46
0BF8:  BTFSS  03.2
0BF9:  GOTO   414
....................    output_low(PIN_B0); 
0BFA:  BCF    06.0
....................    output_low(PIN_B1); 
0BFB:  BCF    06.1
....................    output_low(PIN_B2); 
0BFC:  BCF    06.2
....................    output_low(PIN_B3); 
0BFD:  BCF    06.3
....................   output_low(PIN_B4); 
0BFE:  BCF    06.4
....................    output_low(PIN_B5); 
0BFF:  BCF    06.5
....................    output_low(PIN_B6); 
0C00:  BCF    06.6
....................    output_low(PIN_B7); 
0C01:  BCF    06.7
....................    lcd_init(); // Inicialzacón de la LCD 
0C02:  BCF    0A.3
0C03:  CALL   1B6
0C04:  BSF    0A.3
....................    lcd_gotoxy(1,1); 
0C05:  MOVLW  01
0C06:  MOVWF  57
0C07:  MOVWF  58
0C08:  BCF    0A.3
0C09:  CALL   139
0C0A:  BSF    0A.3
....................    lcd_putc(" STOP");  
0C0B:  MOVLW  A8
0C0C:  BSF    03.6
0C0D:  MOVWF  0D
0C0E:  MOVLW  00
0C0F:  MOVWF  0F
0C10:  BCF    0A.3
0C11:  BCF    03.6
0C12:  CALL   170
0C13:  BSF    0A.3
....................    
.................... } 
.................... } 
0C14:  GOTO   2D3
.................... } 
.................... }} 
0C15:  GOTO   2BF
0C16:  SLEEP

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
